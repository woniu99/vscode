# chapter 8 确认访问用户身份的认证
## 1.HTTP使用的认证方式：
### 1.1 BASIC认证（基本认证）
- BASIC认证是Web服务器与通信客户端之间进行的认证方式，采用Base64编码方式，但不作加密处理。
### 1.2 DIGEST(摘要认证)
- DIGEST认证使用质询/响应的方式（challenges/response），但不会像BISIC认证那样直接发送明文密码。质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。
### 1.3 SSL客户端认证
- SSL客户端认证的认证步骤：
    为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。
1. 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书以Client Certificate报文方式发送给服务器。
3. 服务器验证客户端证书通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。
- 使用SSL客户端认证需要用到客户端证书，而客户端证书需要支付一定的费用才能使用。
### 1.4 基于表单认证
- 基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登陆信息，按登陆信息的验证结果认证。因此多半认证是基于表单认证。
- HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户继续访问，也无法区分他与其他用户。于是我们会使用Cookie类管理Section，以弥补HTTP协议中不存在的状态管理功能。
- 步骤： 
1. 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。
2. 服务器会发放用以识别用户的Session ID.通过验证从客户端发过来的登陆信息进行身份认证，然后把用户的认证状态与Section ID绑定后记录在服务器端。      
    向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSION=028a8c）.
    你可以把Seccion ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性。
3. 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID，所以Session ID也随之发送到服务器。
    服务器端可通过验证接收到Session ID识别用户和其认证状态。